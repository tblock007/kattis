# A class that simply aggregates (attack, defense, hp) information
# A separate class is defined here to enable use of Python's sorting 
# facilities to solve the problem.
class pokenom:
    def __init__(self, a, d, h):
        self.a, self.d, self.h = a, d, h

    # This just allows pokenom's to be printed nicely
    def __str__(self):
        return 'Attack: {0}, Defense: {1}, Health: {2}'.format(self.a, self.d, self.h)

    
# Read the input and store available pokenom in "box"
n, k = [int(w) for w in input().split()]
box = []
for _ in range(n):
    a, d, h = [int(w) for w in input().split()]
    box.append(pokenom(a, d, h))


# Creates three SEPARATE sets by sorting the list (box) three times
# Each sort is done with a different "key"; i.e., once it is sorted 
# by attack, once it is sorted by defense, and once it is sorted by 
# health.  The slice operator is used to select the top k pokenom 
# in each category.
bestA = set(sorted(box, key = lambda p: p.a, reverse = True)[:k])
bestD = set(sorted(box, key = lambda p: p.d, reverse = True)[:k])
bestH = set(sorted(box, key = lambda p: p.h, reverse = True)[:k])

# Performs a "set union".  Note that sets in Python do not allow 
# duplicate elements, so Python will take care of filtering out 
# duplicates here for you.
team = bestA | bestD | bestH

# The number of pokenom's on our team is then simply the number 
# of elements in the final set.
print(len(team))


# For printing the sets generated by the sort
# for p in bestA:
#     print(p)
# print()
# for p in bestD:
#     print(p)
# print()
# for p in bestH:
#     print(p)
# print()
